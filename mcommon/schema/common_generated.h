// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMON_MGEO_H_
#define FLATBUFFERS_GENERATED_COMMON_MGEO_H_

#include "flatbuffers/flatbuffers.h"

#include "glm/glm.hpp"

namespace MGeo {

struct ivec2;

struct ivec3;

struct ivec4;

struct vec2;

struct vec3;

struct vec4;

struct u8vec4;

struct mat4;

struct Color;

struct Bounds;

MANUALLY_ALIGNED_STRUCT(4) ivec2 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "MGeo.ivec2";
  }
  ivec2() {
    memset(this, 0, sizeof(ivec2));
  }
  ivec2(const ivec2 &_o) {
    memcpy(this, &_o, sizeof(ivec2));
  }
  ivec2(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
STRUCT_END(ivec2, 8);

MANUALLY_ALIGNED_STRUCT(4) ivec3 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  int32_t z_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "MGeo.ivec3";
  }
  ivec3() {
    memset(this, 0, sizeof(ivec3));
  }
  ivec3(const ivec3 &_o) {
    memcpy(this, &_o, sizeof(ivec3));
  }
  ivec3(int32_t _x, int32_t _y, int32_t _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  int32_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
STRUCT_END(ivec3, 12);

MANUALLY_ALIGNED_STRUCT(4) ivec4 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  int32_t z_;
  int32_t w_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "MGeo.ivec4";
  }
  ivec4() {
    memset(this, 0, sizeof(ivec4));
  }
  ivec4(const ivec4 &_o) {
    memcpy(this, &_o, sizeof(ivec4));
  }
  ivec4(int32_t _x, int32_t _y, int32_t _z, int32_t _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  int32_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
  int32_t w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
STRUCT_END(ivec4, 16);

MANUALLY_ALIGNED_STRUCT(4) vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "MGeo.vec2";
  }
  vec2() {
    memset(this, 0, sizeof(vec2));
  }
  vec2(const vec2 &_o) {
    memcpy(this, &_o, sizeof(vec2));
  }
  vec2(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
STRUCT_END(vec2, 8);

MANUALLY_ALIGNED_STRUCT(4) vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "MGeo.vec3";
  }
  vec3() {
    memset(this, 0, sizeof(vec3));
  }
  vec3(const vec3 &_o) {
    memcpy(this, &_o, sizeof(vec3));
  }
  vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
STRUCT_END(vec3, 12);

MANUALLY_ALIGNED_STRUCT(4) vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "MGeo.vec4";
  }
  vec4() {
    memset(this, 0, sizeof(vec4));
  }
  vec4(const vec4 &_o) {
    memcpy(this, &_o, sizeof(vec4));
  }
  vec4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
STRUCT_END(vec4, 16);

MANUALLY_ALIGNED_STRUCT(1) u8vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t x_;
  uint8_t y_;
  uint8_t z_;
  uint8_t w_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "MGeo.u8vec4";
  }
  u8vec4() {
    memset(this, 0, sizeof(u8vec4));
  }
  u8vec4(const u8vec4 &_o) {
    memcpy(this, &_o, sizeof(u8vec4));
  }
  u8vec4(uint8_t _x, uint8_t _y, uint8_t _z, uint8_t _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  uint8_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  uint8_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  uint8_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
  uint8_t w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
STRUCT_END(u8vec4, 4);

MANUALLY_ALIGNED_STRUCT(4) mat4 FLATBUFFERS_FINAL_CLASS {
 private:
  vec4 c0_;
  vec4 c1_;
  vec4 c2_;
  vec4 c3_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "MGeo.mat4";
  }
  mat4() {
    memset(this, 0, sizeof(mat4));
  }
  mat4(const mat4 &_o) {
    memcpy(this, &_o, sizeof(mat4));
  }
  mat4(const vec4 &_c0, const vec4 &_c1, const vec4 &_c2, const vec4 &_c3)
      : c0_(_c0),
        c1_(_c1),
        c2_(_c2),
        c3_(_c3) {
  }
  const vec4 &c0() const {
    return c0_;
  }
  const vec4 &c1() const {
    return c1_;
  }
  const vec4 &c2() const {
    return c2_;
  }
  const vec4 &c3() const {
    return c3_;
  }
};
STRUCT_END(mat4, 64);

MANUALLY_ALIGNED_STRUCT(4) Color FLATBUFFERS_FINAL_CLASS {
 private:
  float r_;
  float g_;
  float b_;
  float a_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "MGeo.Color";
  }
  Color() {
    memset(this, 0, sizeof(Color));
  }
  Color(const Color &_o) {
    memcpy(this, &_o, sizeof(Color));
  }
  Color(float _r, float _g, float _b, float _a)
      : r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)),
        a_(flatbuffers::EndianScalar(_a)) {
  }
  float r() const {
    return flatbuffers::EndianScalar(r_);
  }
  float g() const {
    return flatbuffers::EndianScalar(g_);
  }
  float b() const {
    return flatbuffers::EndianScalar(b_);
  }
  float a() const {
    return flatbuffers::EndianScalar(a_);
  }
};
STRUCT_END(Color, 16);

MANUALLY_ALIGNED_STRUCT(4) Bounds FLATBUFFERS_FINAL_CLASS {
 private:
  vec3 min_;
  vec3 max_;

 public:
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "MGeo.Bounds";
  }
  Bounds() {
    memset(this, 0, sizeof(Bounds));
  }
  Bounds(const Bounds &_o) {
    memcpy(this, &_o, sizeof(Bounds));
  }
  Bounds(const vec3 &_min, const vec3 &_max)
      : min_(_min),
        max_(_max) {
  }
  const vec3 &min() const {
    return min_;
  }
  const vec3 &max() const {
    return max_;
  }
};
STRUCT_END(Bounds, 24);

}  // namespace MGeo

#endif  // FLATBUFFERS_GENERATED_COMMON_MGEO_H_
